---
title: 程序员的自我修养笔记之动态链接
date: 2019-3-4 18:53:12
categories: codenote
tags: [OS, Linux]

typora-copy-images-to: 程序员的自我修养笔记之动态链接

---

《程序员的自我修养笔记之动态链接》 3

动态链接原理

<!--more-->

#### 动态链接产生的原因

- 节省内存和磁盘空间
- 便于程序的开发，发布和更新
- 程序可扩展性和兼容性，可被人们用来制作程序插件

#### 动态链接的基本实现

##### 基本思想

把程序按照模块分拆开来形成各个相对独立的部分，在程序运行时将它们链接在一起形成一个完整的程序，静态链接则把所有程序模块都链接成一个单独的可执行文件。

##### 基本概念

Linux系统中，ELF动态链接万剑被称为**动态共享对象(DSO，Dynamic Shared Objects)**，简称**共享对象**，它们们一般都是以“.so”为扩展名。Windows中动态链接文件被称为**动态链接库（Dynamical Linking Library）**，它通常就是平时见到的以".dll"为扩展名的文件

##### 动态链接器

程序与so文件之间真正的链接工作由动态链接器完成，而不是ld完成。

#### 简单例子
Program1.c
```c
#include "Lib.h"

int main(int argc, char const *argv[])
{
	foobar(1);
	return 0;
}
```
Program2.c
```c
#include "Lib.h"

int main(int argc, char const *argv[])
{
	foobar(2);
	return 0;
}
```
Lib.c

```c
#include <stdio.h>

void foobar(int i){

printf("Printing from Lib.so %d \n", i );
sleep(-1);
}
```
Lib.h
```c
#ifndef LIB_H
#define LIB_H

void foobar(int i);

#endif
```

`gcc -fPIC -shared -o Lib.so Lib.c`

`gcc -o Program1 Program1.c ./Lib.so `

`gcc -o Program2 Program2.c ./Lib.so `

可以从图中看到相应动态链接库在进程中的内存映射

![1552206133471](程序员的自我修养笔记之动态链接/1552206133471.png)

`readelf -l Lib.so`

![1552206531897](程序员的自我修养笔记之动态链接/1552206531897.png)

可以看到动态链接模块的装载地址从`0x0`开始，这是因为**共享对象最终装载地址在编译时是不确定的**，而是装载器根据当前地址空间的空闲情况，动态分配一块足够大的虚拟地址空间给到相应的共享对象。

#### 地址无关代码

为了解决静态链接会发生装载的模块目标地址产生冲突的问题(也就是模块A与模块C目标被分配到了相同地址)的问题，提出**装载时重定位**和**地址无关代码**

- 装载时重定位

  `gcc  -shared -o Lib.so Lib.c`

  当模块在装载时，装载地址确定，也就表示目标地址确定，系统只要对程序中所有的绝对地址引用进行重定位即可。但缺点在于，由于指令部分也跟着被重定位，指令无法在多个进程内共同使用这样就失去了动态链接节省内存的一大优势。

- 地址无关代码（PIC）

  `gcc -fPIC -shared -o Lib.so Lib.c`

  - 目的：保证程序模块中指令部分在装载时不需要因为装载地址的改变而改变
  - 做法：分离指令中需要被修改的部分，并将其与数据部分放在一起，这样指令部分就可以保持不变，而数据部分在每个进程里都拥有一个副本

  这样我们就可以知道，模块引用分如下四个类型

  - 模块内部的函数调用、跳转等
  - 模块内部的数据访问，比如模块中定义的全局变量，静态变量g
  - 模块外部的函数调用、跳转等
  - 模块外部的数据访问，如其他模块中的全局变量

  ![1552208099923](程序员的自我修养笔记之动态链接/1552208099923.png)

##### 类型一 模块内调用或者跳转

使用相对地址调用或者基于寄存器的相对调用

![1552209698461](程序员的自我修养笔记之动态链接/1552209698461.png)

其中`0xffffffcc`是十进制`-52`的补码，也就是说，此条指令的下一条指令地址`799 `再减去`(-52)`得到`foo()`函数的地址。

##### 类型二 模块内数据访问

由于三级流水的工作原理，rip寄存器地址指向的是下一条指令所在地址，计算方式实质上是以相对地址寻址的方式进行。

![1552212257328](程序员的自我修养笔记之动态链接/1552212257328.png)

##### 类型三 模块间数据访问

如上图b变量，所在地址值为`0x08102000`，而貌似并不经过`.got`表。和书上不一样，但运行后的确能得到`so`里面的b值，然后`dumpobj -R`查看需要动态重定位的部分，得到如下数据：

![1552216705631](程序员的自我修养笔记之动态链接/1552216705631.png)

这与书中一样，但可以肯定的是，这个信息告诉了操作系统，这个数据可以从别的文件中的数据进行初始化。

于是作一个猜想，如果多个模块中具有相同符号的`extern`变量会发生什么呢？

编写第三个模块`fpic3.so`

```c
extern int b = 10;
```

如果不进行链接，则结果b的值为0：

![1552217637457](程序员的自我修养笔记之动态链接/1552217637457.png)

然后链接顺序为先链接`fpic2.so`再链接`fpic3.co`，得到结果是拿到`fpic3.so`里面的b值：

![1552217405502](程序员的自我修养笔记之动态链接/1552217405502.png)改变链接顺序，则拿到的是`fpic2.so`里面的b值：

![1552217466008](程序员的自我修养笔记之动态链接/1552217466008.png)

这里可以得出一个结论，**如果标记为`extern`的变量，他会告诉操作系统，这个值可以在其他模块中寻找对应的值进行初始化，其值为最后一个链接的模块中对应的值，如果没有发现，则为0，这样也解决了多个共享模块有相同全局符号变量的问题。**

##### 类型四 模块间调用跳转

这种情况要复杂得多，这里出现两个概念：**GOT表**和**plt表**

- GOT表： Global Offset Table，全局偏移表
- PLT表： Procedure Linkage Table，程序联动表，由一个个小段代码组成，这个是延迟绑定技术中不可或缺的部分

`foo()`函数调用`ext()`函数，首先跳转到plt表中的ext项：`ext@plt`

![1552218595254](程序员的自我修养笔记之动态链接/1552218595254.png)

![1552218636662](程序员的自我修养笔记之动态链接/1552218636662.png)

这里可以看到，`ext@plt`其实也是跳转到某个地方，也就是`0x200fd0`处：

![1552218716458](程序员的自我修养笔记之动态链接/1552218716458.png)

发现这个地址位于`.got`表中位置所在值被初始化为`0x066060000`，具体含义目前未知。装载时这里的值会被改写为`ext()`的地址，操作系统根据这个地址进行跳转，原理如下

![1552219020428](程序员的自我修养笔记之动态链接/1552219020428.png)

#### 延迟绑定(PLT)

动态链接性能之所以比静态链接较慢，有如下几点原因

- 对全局和静态的数据访问需要进行复杂的GOT定位，然后间接寻址
- 对于模块间的调用则需要先定位后进行间接跳转
- 动态链接的链接工作需要在运行时完成，寻找并装载所需要的共享对象，然后进行符号查找地址重定位等

#####　延迟绑定的实现

为了尽可能解决动态链接的性能问题，ELF采用**延迟绑定（Lazy Binding）**的做法，基本思想就是当**函数第一次被用到时才进行绑定**，如果没有用到，则不进行绑定。

ELF使用**PLT**的方法来实现。举例子，`liba.so`需要调用`libc.so`的`bar()`函数，那么第一次调用时，需要动态链接器中的某个函数完成地址绑定工作，设此函数为`lookup()`，那么这个函数的参数应该至少是这样的`lookup(module, function)`，来识别哪个模块中的哪个函数进行绑定。在`Glibc`中，`lookup()`函数真正的名字叫做`_dl_runtime_resolve()`。

当调用某个外部模块的函数时，通常的做法应该是通过GOT中相应的项进行间接跳转。PLT为了实现延迟绑定，增加了一层间接跳转。

如上一节**模块间跳转**所述

![1552218636662](程序员的自我修养笔记之动态链接/1552218636662.png)

在我的机器上面，实际上是只有一个参数的，然后一句句来看。

**TODO**

#### 动态链接相关结构

##### `.interp`段

存储声明此ELF文件链接时所需要的动态链接器所在路径，这个位置由ELF文件自己决定

![1552547621402](程序员的自我修养笔记之动态链接/1552547621402.png)

##### `.dynamic`段

保存了ELF文件动态链接器所需要的基本信息，比如依赖哪些共享对象，动态链接表符号表未知，重定位表位置等。

其结构定义如下：

```c
typedef struct{
    Elf32_Sword d_tag;
    union{
        Elf32_Word d_val;
        Elf32_Addr d_ptr;
    } d_un;
} Elf32_Dyn;
```

由一个类型加上一个附加的数值或者指针，对于不同类型，后面的数值或者指针有着不同的含义，如下是常见类型值：

![1552547969352](程序员的自我修养笔记之动态链接/1552547969352.png)

`readelf -d Lib.so`

![1552548118348](程序员的自我修养笔记之动态链接/1552548118348.png)

查看依赖库

`ldd Program1`

![1552548182289](程序员的自我修养笔记之动态链接/1552548182289.png)

##### 动态符号表(.dynsym)

`.dynsym`表只定义了动态链接相关的符号，对于模块内部的符号，比如模块内部的私有变量则不进行保存。而动态链接的模块经常同时拥有“.dynsym”和".symtab"两个表，且".symtab"保存了所有符号，包括“.dynsym”中的符号。为加快符号查找过程，往往还有辅助的符号**哈希表(.hash)**

`.dynstr`是动态符号字符串表，用于辅助动态链接。

查看动态符号表

`readelf -s Lib.so`

![1552548911557](程序员的自我修养笔记之动态链接/1552548911557.png)



#####　动态链接重定位表

PIC模式编译的可执行文件或者共享对象，虽然代码段不需要重定位，但是数据段还包含了绝对地址的引用，这部分是从代码段中分离出来，变成GOT，而GOT是数据段的一部分，除了GOT以外，数据段可能还包含对绝对地址的引用。

##### 动态链接重定位相关结构

- .rel.dyn 是对数据引用的修正，修正位置为“.got”和数据段
- .rel.plt是对函数引用的修正，修正位置为“.got.plt”

`readelf -r Lib.so`

首先是在PIC模式下编译出来的so文件

![1552552579951](程序员的自我修养笔记之动态链接/1552552579951.png)

`printf`和`sleep`符号位于.rela.plt中。

而偏移是位于`.got.plt`表中的:

![1552554182156](程序员的自我修养笔记之动态链接/1552554182156.png)

这个时候我们就可以发现前面还有三项未知，书中称在32位下，是这样的

![1552554507104](程序员的自我修养笔记之动态链接/1552554507104.png)

实际的PLT基本结构代码如下：

![1552554826270](程序员的自我修养笔记之动态链接/1552554826270.png)

PLT在ELF文件中以独立的段存放，通常叫做“.plt”，因为本身是地址无关的代码，所以可以跟代码段等一起合并成一个可读可执行的“Segment”被装载入内存。

但我的64位机器上是明显对不上的，这里留个坑，先作个mark。

当动态链接器需要进行重定位时，首先查找`printf`的地址，然后将地址填入对应的`.got.plt`的位置，从而实现地址的重定位。

类似的`R_X86_64_GLOB_DAT`是对`.got`的重定位，你跟过去发现地址就是落在了`.got`表中。

而最后一个类型是`R_X86_64_RELATIVE`，这个类型实际是**基址重置(Rebasing)**，共享对象的数据段无法做到地址无关，但他可能会包含绝对地址的引用。如下：

```c
static int a;
static int* p = &a;
```

编译时共享对象地址从0开始，假设该静态变量a相对于起始地址的偏移为B，则p的值为B。装载之后，如果共享对象基址为A，则p的值应该是`A + B`

总结起来就是两种重定位方式：

- 装载时，函数符号具体地址根据`plt`的指引，直接填充到`.got`的对应位置。
- 装载时，绝对地址的引用具体地址根据`plt`的指引，以A+B的形式填充到`.data`的对应位置。

然后是非PIC方式编译的so。

emmm本机器上面好像不允许这么干了

![1552558581724](程序员的自我修养笔记之动态链接/1552558581724.png)

